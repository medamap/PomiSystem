<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHARP X1 PCG Converter</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --text-primary: #eee;
            --text-secondary: #aaa;
            --border: #333;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', 'Meiryo', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        
        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        header p {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border);
        }
        
        .panel h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--accent);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .control-group .value {
            float: right;
            color: var(--accent);
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
        }
        
        .range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent);
            color: white;
            width: 100%;
        }
        
        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--border);
        }
        
        .btn-small {
            padding: 8px 12px;
            font-size: 0.85em;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .btn-group .btn {
            flex: 1;
        }
        
        .file-input-wrapper {
            position: relative;
            margin-bottom: 15px;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 40px 20px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .file-input-label:hover {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.1);
        }
        
        .file-input-label.dragover {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.2);
        }
        
        .preview-area {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .preview-area img {
            max-width: 100%;
            max-height: 200px;
            image-rendering: pixelated;
        }
        
        .preview-area .placeholder {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .output-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 800px) {
            .output-section {
                grid-template-columns: 1fr;
            }
        }
        
        .output-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border);
        }
        
        .output-panel h3 {
            font-size: 1em;
            margin-bottom: 15px;
            color: var(--accent);
        }
        
        .output-canvas-wrapper {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            margin-bottom: 15px;
            overflow: auto;
        }
        
        .output-canvas-wrapper canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .zoom-controls {
            display: flex;
            gap: 3px;
            margin-bottom: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .zoom-btn {
            padding: 4px 8px;
            font-size: 0.75em;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            cursor: pointer;
            min-width: 32px;
        }
        
        .zoom-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        .zoom-btn:hover:not(.active) {
            background: var(--bg-secondary);
        }
        
        .info-panel {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .info-panel h4 {
            font-size: 0.9em;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
        }
        
        .info-item .label {
            color: var(--text-secondary);
        }
        
        .info-item .value {
            color: var(--accent);
            font-weight: bold;
        }
        
        .pcg-usage {
            margin-top: 15px;
        }
        
        .pcg-bar {
            height: 20px;
            background: var(--bg-primary);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .pcg-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .pcg-bar-fill.warning {
            background: #ffff00;
        }
        
        .pcg-bar-fill.danger {
            background: #ff0000;
        }
        
        .color-palette {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid var(--border);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent);
        }
        
        .section-divider {
            height: 1px;
            background: var(--border);
            margin: 20px 0;
        }
        
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: none;
        }

        .processing-overlay.active {
            display: block;
        }

        .processing-content {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 90%;
            max-width: 450px;
        }
        
        .progress-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 25px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .progress-title {
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .progress-percent {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--accent);
        }
        
        .progress-phase {
            color: var(--text-secondary);
            margin-bottom: 15px;
            font-size: 0.95em;
        }
        
        .progress-bar-outer {
            width: 100%;
            height: 24px;
            background: var(--bg-primary);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            border-radius: 12px;
            transition: width 0.15s ease-out;
        }
        
        .progress-detail {
            color: var(--text-secondary);
            font-size: 0.9em;
            min-height: 20px;
            margin-bottom: 15px;
        }
        
        .progress-cancel {
            margin-top: 10px;
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: var(--accent);
            color: white;
            border-radius: 8px;
            font-weight: 600;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1001;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .settings-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ–¥ï¸ SHARP X1 PCG Converter</h1>
            <p>ãƒ‡ã‚¸ã‚¿ãƒ«8è‰² Ã— 8Ã—8 PCGã‚¿ã‚¤ãƒ«å¤‰æ›ãƒ„ãƒ¼ãƒ«ï¼ˆæ‹¡å¼µç‰ˆ: æœ€å¤§2048 PCGå¯¾å¿œï¼‰</p>
        </header>
        
        <div class="main-layout">
            <!-- Left Panel: Controls -->
            <div class="controls-column">
                <div class="panel">
                    <h2>ğŸ“ ç”»åƒå…¥åŠ›</h2>
                    <div class="file-input-wrapper">
                        <input type="file" id="imageInput" accept="image/*">
                        <div class="file-input-label" id="dropZone">
                            <span>ğŸ“· ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</span>
                        </div>
                    </div>
                    <div class="preview-area" id="inputPreview">
                        <span class="placeholder">ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„</span>
                    </div>
                    
                    <button class="btn btn-primary" id="convertBtnTop" style="margin-top: 15px;">
                        ğŸ”„ å¤‰æ›å®Ÿè¡Œ
                    </button>
                </div>
                
                <div class="panel" style="margin-top: 20px;">
                    <h2>âš™ï¸ å¤‰æ›è¨­å®š</h2>
                    
                    <div class="control-group">
                        <label>
                            å‡ºåŠ›ã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰
                        </label>
                        <select id="outputMode">
                            <optgroup label="X1turboç³»">
                                <option value="x1" selected>X1turboï¼ˆ320Ã—200ï¼‰</option>
                                <option value="x1x2">X1turbo Ã—2ï¼ˆ640Ã—400ï¼‰</option>
                                <option value="x1x4">X1turbo Ã—4ï¼ˆ1280Ã—800ï¼‰</option>
                            </optgroup>
                            <optgroup label="ã‚ªãƒ¼ãƒˆï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒï¼‰">
                                <option value="auto">ã‚ªãƒ¼ãƒˆ</option>
                                <option value="autox2">ã‚ªãƒ¼ãƒˆ Ã—2</option>
                                <option value="autox4">ã‚ªãƒ¼ãƒˆ Ã—4</option>
                            </optgroup>
                            <optgroup label="æ¨™æº–è§£åƒåº¦">
                                <option value="qvga">QVGAï¼ˆ320Ã—240ï¼‰</option>
                                <option value="vga">VGAï¼ˆ640Ã—480ï¼‰</option>
                            </optgroup>
                            <optgroup label="é«˜è§£åƒåº¦ï¼ˆç„¡åˆ¶é™ãƒ¢ãƒ¼ãƒ‰è‡ªå‹•ï¼‰">
                                <option value="svga">SVGAï¼ˆ800Ã—600ï¼‰</option>
                                <option value="xga">XGAï¼ˆ1024Ã—768ï¼‰</option>
                                <option value="sxga">SXGAï¼ˆ1280Ã—1024ï¼‰</option>
                                <option value="hd">HDï¼ˆ1280Ã—720ï¼‰</option>
                                <option value="uxga">UXGAï¼ˆ1600Ã—1200ï¼‰</option>
                                <option value="fhd">FHDï¼ˆ1920Ã—1080ï¼‰</option>
                                <option value="wuxga">WUXGAï¼ˆ1920Ã—1200ï¼‰</option>
                                <option value="qhd">QHDï¼ˆ2560Ã—1440ï¼‰</option>
                                <option value="qxga">QXGAï¼ˆ2048Ã—1536ï¼‰</option>
                                <option value="uhd">UHD/4Kï¼ˆ3840Ã—2160ï¼‰</option>
                            </optgroup>
                        </select>
                        <div class="retro-info" id="highResNote" style="display: none;">
                            âš ï¸ é«˜è§£åƒåº¦ãƒ¢ãƒ¼ãƒ‰ã§ã¯ç„¡åˆ¶é™ãŒè‡ªå‹•é©ç”¨ã•ã‚Œã¾ã™
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            ãƒˆãƒªãƒŸãƒ³ã‚°ä½ç½®
                            <span class="value" id="cropPositionValue">50%</span>
                        </label>
                        <input type="range" id="cropPosition" min="25" max="75" value="50">
                        <div class="range-labels">
                            <span id="cropLabelLeft">ä¸Š/å·¦</span>
                            <span>ä¸­å¤®</span>
                            <span id="cropLabelRight">ä¸‹/å³</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°æ–¹å¼
                        </label>
                        <select id="ditherMode">
                            <option value="none">ãªã—ï¼ˆæœ€è¿‘å‚è‰²ï¼‰</option>
                            <option value="bayer2">Ordered Dither (Bayer 2Ã—2)</option>
                            <option value="bayer4" selected>Ordered Dither (Bayer 4Ã—4)</option>
                            <option value="floyd">Floyd-Steinberg</option>
                            <option value="atkinson">Atkinson</option>
                        </select>
                    </div>
                    
                    <div class="section-divider"></div>
                    
                    <h2>ğŸŒˆ è‰²ç›¸è€ƒæ…®ï¼ˆè‚Œè‰²æ”¹å–„ï¼‰</h2>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="hueWeight" checked>
                        <label for="hueWeight">è‰²ç›¸ã‚’è€ƒæ…®ã—ãŸè‰²é¸æŠ</label>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            è‰²ç›¸é‡è¦–åº¦
                            <span class="value" id="hueWeightValue">30%</span>
                        </label>
                        <input type="range" id="hueWeightAmount" min="0" max="100" value="30">
                        <div class="range-labels">
                            <span>RGBé‡è¦–</span>
                            <span>è‰²ç›¸é‡è¦–</span>
                        </div>
                    </div>
                    
                    <div class="retro-info">
                        ğŸ’¡ è‚Œè‰²ãªã©ã®ä¸­é–“è‰²ãŒé»„è‰²ã£ã½ããªã‚‹ã®ã‚’è»½æ¸›
                    </div>
                    
                    <div class="section-divider"></div>
                    
                    <h2>ğŸ”² PCGè¨­å®š</h2>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="pcgUnlimited">
                        <label for="pcgUnlimited">ç„¡åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒªãƒ‡ãƒ¥ãƒ¼ã‚¹ãªã—ãƒ»é«˜é€Ÿï¼‰</label>
                    </div>
                    
                    <div id="pcgLimitSettings">
                        <div class="control-group">
                            <label>
                                PCGå®šç¾©æ•°ä¸Šé™
                                <span class="value" id="pcgLimitValue">256</span>
                            </label>
                            <input type="range" id="pcgLimit" min="128" max="2048" step="32" value="256">
                            <div class="range-labels">
                                <span>128</span>
                                <span>X1æ¨™æº–:256</span>
                                <span>2048</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>
                                ã‚¿ã‚¤ãƒ«é¡ä¼¼åº¦é–¾å€¤
                                <span class="value" id="similarityValue">15</span>
                            </label>
                            <input type="range" id="similarity" min="0" max="50" value="15">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="edgeProtection" checked>
                            <label for="edgeProtection">ã‚¨ãƒƒã‚¸ã‚¿ã‚¤ãƒ«ä¿è­·ï¼ˆè¼ªéƒ­ã‚’å„ªå…ˆä¿æŒï¼‰</label>
                        </div>
                        
                        <div class="control-group">
                            <label>
                                ã‚¨ãƒƒã‚¸ä¿è­·å¼·åº¦
                                <span class="value" id="edgeProtectionValue">50%</span>
                            </label>
                            <input type="range" id="edgeProtectionAmount" min="0" max="100" value="50">
                        </div>
                        
                        <div class="retro-info">
                            ğŸ’¡ ã‚¨ãƒƒã‚¸ä¿è­·: è¼ªéƒ­ã‚’å«ã‚€ã‚¿ã‚¤ãƒ«ã‚’ãƒªãƒ‡ãƒ¥ãƒ¼ã‚¹æ™‚ã«å„ªå…ˆä¿æŒ
                        </div>
                    </div>
                    
                    <div class="section-divider"></div>
                    
                    <h2>ğŸ¨ è‰²èª¿æ•´ï¼ˆæ¸›è‰²å‰ï¼‰</h2>
                    
                    <div class="control-group">
                        <label>
                            æ˜åº¦
                            <span class="value" id="brightnessValue">0</span>
                        </label>
                        <input type="range" id="brightness" min="-100" max="100" value="0">
                    </div>
                    
                    <div class="control-group">
                        <label>
                            ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ
                            <span class="value" id="contrastValue">0</span>
                        </label>
                        <input type="range" id="contrast" min="-100" max="100" value="0">
                    </div>
                    
                    <div class="control-group">
                        <label>
                            å½©åº¦
                            <span class="value" id="saturationValue">0</span>
                        </label>
                        <input type="range" id="saturation" min="-100" max="100" value="0">
                    </div>
                    
                    <div class="section-divider"></div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="realtimePreview">
                        <label for="realtimePreview">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆé‡ã„å ´åˆã¯OFFæ¨å¥¨ï¼‰</label>
                    </div>
                    
                    <button class="btn btn-primary" id="convertBtn">
                        ğŸ”„ å¤‰æ›å®Ÿè¡Œ
                    </button>
                    
                    <div class="settings-footer">
                        <div class="btn-group">
                            <button class="btn btn-secondary btn-small" id="saveSettings">
                                ğŸ’¾ è¨­å®šä¿å­˜
                            </button>
                            <button class="btn btn-secondary btn-small" id="resetSettings">
                                ğŸ”„ ãƒªã‚»ãƒƒãƒˆ
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Color Palette Reference -->
                <div class="panel" style="margin-top: 20px;">
                    <h2>ğŸ¨ ãƒ‡ã‚¸ã‚¿ãƒ«8è‰²ãƒ‘ãƒ¬ãƒƒãƒˆ</h2>
                    <div class="color-palette">
                        <div class="color-swatch" style="background: #000000;" title="Black"></div>
                        <div class="color-swatch" style="background: #0000FF;" title="Blue"></div>
                        <div class="color-swatch" style="background: #FF0000;" title="Red"></div>
                        <div class="color-swatch" style="background: #00FF00;" title="Green"></div>
                        <div class="color-swatch" style="background: #FF00FF;" title="Purple"></div>
                        <div class="color-swatch" style="background: #00FFFF;" title="Cyan"></div>
                        <div class="color-swatch" style="background: #FFFF00;" title="Yellow"></div>
                        <div class="color-swatch" style="background: #FFFFFF;" title="White"></div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Output -->
            <div class="output-column">
                <div class="output-section">
                    <div class="output-panel">
                        <h3>ğŸ“º å‡ºåŠ›ç”»åƒ</h3>
                        <div class="zoom-controls">
                            <button class="zoom-btn active" data-zoom="fit" data-target="output">FIT</button>
                            <button class="zoom-btn" data-zoom="0.125" data-target="output">â…›</button>
                            <button class="zoom-btn" data-zoom="0.25" data-target="output">Â¼</button>
                            <button class="zoom-btn" data-zoom="0.5" data-target="output">Â½</button>
                            <button class="zoom-btn" data-zoom="1" data-target="output">1x</button>
                            <button class="zoom-btn" data-zoom="2" data-target="output">2x</button>
                            <button class="zoom-btn" data-zoom="3" data-target="output">3x</button>
                            <button class="zoom-btn" data-zoom="4" data-target="output">4x</button>
                        </div>
                        <div class="output-canvas-wrapper" id="outputWrapper">
                            <canvas id="outputCanvas"></canvas>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-secondary btn-small" id="downloadOutput">
                                ğŸ’¾ ä¿å­˜
                            </button>
                            <button class="btn btn-secondary btn-small" id="copyOutput">
                                ğŸ“‹ ã‚³ãƒ”ãƒ¼
                            </button>
                        </div>
                    </div>
                    
                    <div class="output-panel">
                        <h3>ğŸ§© PCGå®šç¾©ç”»åƒ</h3>
                        <div class="zoom-controls">
                            <button class="zoom-btn active" data-zoom="fit" data-target="pcg">FIT</button>
                            <button class="zoom-btn" data-zoom="0.125" data-target="pcg">â…›</button>
                            <button class="zoom-btn" data-zoom="0.25" data-target="pcg">Â¼</button>
                            <button class="zoom-btn" data-zoom="0.5" data-target="pcg">Â½</button>
                            <button class="zoom-btn" data-zoom="1" data-target="pcg">1x</button>
                            <button class="zoom-btn" data-zoom="2" data-target="pcg">2x</button>
                            <button class="zoom-btn" data-zoom="3" data-target="pcg">3x</button>
                            <button class="zoom-btn" data-zoom="4" data-target="pcg">4x</button>
                        </div>
                        <div class="output-canvas-wrapper" id="pcgWrapper">
                            <canvas id="pcgCanvas"></canvas>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-secondary btn-small" id="downloadPcg">
                                ğŸ’¾ ä¿å­˜
                            </button>
                            <button class="btn btn-secondary btn-small" id="copyPcg">
                                ğŸ“‹ ã‚³ãƒ”ãƒ¼
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Info Panel -->
                <div class="info-panel">
                    <h4>ğŸ“Š å‡ºåŠ›æƒ…å ±</h4>
                    <div class="info-grid">
                        <div class="info-item">
                            <span class="label">å‡ºåŠ›è§£åƒåº¦:</span>
                            <span class="value" id="infoResolution">-</span>
                        </div>
                        <div class="info-item">
                            <span class="label">ã‚¿ã‚¤ãƒ«æ•°:</span>
                            <span class="value" id="infoTiles">-</span>
                        </div>
                        <div class="info-item">
                            <span class="label">ä½¿ç”¨PCGæ•°:</span>
                            <span class="value" id="infoPcgUsed">-</span>
                        </div>
                        <div class="info-item">
                            <span class="label">PCGä¸Šé™:</span>
                            <span class="value" id="infoPcgLimit">256</span>
                        </div>
                        <div class="info-item">
                            <span class="label">ãƒˆãƒªãƒŸãƒ³ã‚°:</span>
                            <span class="value" id="infoCrop">-</span>
                        </div>
                        <div class="info-item">
                            <span class="label">8pxæ•´åˆ—:</span>
                            <span class="value" id="infoAlign">âœ“</span>
                        </div>
                    </div>
                    <div class="pcg-usage">
                        <div style="display: flex; justify-content: space-between; font-size: 0.85em;">
                            <span>PCGä½¿ç”¨ç‡</span>
                            <span id="pcgPercentage">0%</span>
                        </div>
                        <div class="pcg-bar">
                            <div class="pcg-bar-fill" id="pcgBarFill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Processing Overlay with Progress -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-content">
            <div class="progress-container">
                <div class="progress-header">
                    <span class="progress-title" id="progressTitle">ğŸ”„ å¤‰æ›å‡¦ç†ä¸­...</span>
                    <span class="progress-percent" id="progressPercent">0%</span>
                </div>
                <div class="progress-phase" id="progressPhase">ãƒ•ã‚§ãƒ¼ã‚º 1/7: å‰å‡¦ç†</div>
                <div class="progress-bar-outer">
                    <div class="progress-bar-inner" id="progressBar" style="width: 0%;"></div>
                </div>
                <div class="progress-detail" id="progressDetail"></div>
                <button class="btn btn-secondary progress-cancel" id="progressCancel">âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <script>
        // Digital 8 colors
        const PALETTE = [
            { r: 0, g: 0, b: 0, name: 'Black' },
            { r: 0, g: 0, b: 255, name: 'Blue' },
            { r: 255, g: 0, b: 0, name: 'Red' },
            { r: 0, g: 255, b: 0, name: 'Green' },
            { r: 255, g: 0, b: 255, name: 'Purple' },
            { r: 0, g: 255, b: 255, name: 'Cyan' },
            { r: 255, g: 255, b: 0, name: 'Yellow' },
            { r: 255, g: 255, b: 255, name: 'White' }
        ];
        
        // Bayer matrices
        const BAYER2 = [
            [0, 2],
            [3, 1]
        ];
        
        const BAYER4 = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];
        
        // State
        let sourceImage = null;
        let outputZoom = 'fit';
        let pcgZoom = 'fit';
        let convertTimeout = null;
        let currentWorker = null;
        let conversionCancelled = false;
        
        // DOM Elements
        const elements = {
            imageInput: document.getElementById('imageInput'),
            dropZone: document.getElementById('dropZone'),
            inputPreview: document.getElementById('inputPreview'),
            outputMode: document.getElementById('outputMode'),
            highResNote: document.getElementById('highResNote'),
            cropPosition: document.getElementById('cropPosition'),
            cropPositionValue: document.getElementById('cropPositionValue'),
            cropLabelLeft: document.getElementById('cropLabelLeft'),
            cropLabelRight: document.getElementById('cropLabelRight'),
            ditherMode: document.getElementById('ditherMode'),
            hueWeight: document.getElementById('hueWeight'),
            hueWeightAmount: document.getElementById('hueWeightAmount'),
            hueWeightValue: document.getElementById('hueWeightValue'),
            pcgUnlimited: document.getElementById('pcgUnlimited'),
            pcgLimitSettings: document.getElementById('pcgLimitSettings'),
            pcgLimit: document.getElementById('pcgLimit'),
            pcgLimitValue: document.getElementById('pcgLimitValue'),
            similarity: document.getElementById('similarity'),
            similarityValue: document.getElementById('similarityValue'),
            edgeProtection: document.getElementById('edgeProtection'),
            edgeProtectionAmount: document.getElementById('edgeProtectionAmount'),
            edgeProtectionValue: document.getElementById('edgeProtectionValue'),
            brightness: document.getElementById('brightness'),
            brightnessValue: document.getElementById('brightnessValue'),
            contrast: document.getElementById('contrast'),
            contrastValue: document.getElementById('contrastValue'),
            saturation: document.getElementById('saturation'),
            saturationValue: document.getElementById('saturationValue'),
            realtimePreview: document.getElementById('realtimePreview'),
            convertBtn: document.getElementById('convertBtn'),
            convertBtnTop: document.getElementById('convertBtnTop'),
            saveSettings: document.getElementById('saveSettings'),
            resetSettings: document.getElementById('resetSettings'),
            outputCanvas: document.getElementById('outputCanvas'),
            pcgCanvas: document.getElementById('pcgCanvas'),
            outputWrapper: document.getElementById('outputWrapper'),
            pcgWrapper: document.getElementById('pcgWrapper'),
            downloadOutput: document.getElementById('downloadOutput'),
            copyOutput: document.getElementById('copyOutput'),
            downloadPcg: document.getElementById('downloadPcg'),
            copyPcg: document.getElementById('copyPcg'),
            infoResolution: document.getElementById('infoResolution'),
            infoTiles: document.getElementById('infoTiles'),
            infoPcgUsed: document.getElementById('infoPcgUsed'),
            infoPcgLimit: document.getElementById('infoPcgLimit'),
            infoCrop: document.getElementById('infoCrop'),
            infoAlign: document.getElementById('infoAlign'),
            pcgPercentage: document.getElementById('pcgPercentage'),
            pcgBarFill: document.getElementById('pcgBarFill'),
            processingOverlay: document.getElementById('processingOverlay'),
            progressTitle: document.getElementById('progressTitle'),
            progressPercent: document.getElementById('progressPercent'),
            progressPhase: document.getElementById('progressPhase'),
            progressBar: document.getElementById('progressBar'),
            progressDetail: document.getElementById('progressDetail'),
            progressCancel: document.getElementById('progressCancel'),
            toast: document.getElementById('toast')
        };
        
        // Default settings
        const defaultSettings = {
            outputMode: 'x1',
            cropPosition: 50,
            ditherMode: 'bayer4',
            hueWeight: true,
            hueWeightAmount: 30,
            pcgUnlimited: false,
            pcgLimit: 256,
            similarity: 15,
            edgeProtection: true,
            edgeProtectionAmount: 50,
            brightness: 0,
            contrast: 0,
            saturation: 0,
            realtimePreview: false
        };
        
        // PCG slider step
        const PCG_STEP = 32;
        
        // Initialize
        function init() {
            loadSettings();
            setupEventListeners();
            updateAllValues();
            updatePcgLimitVisibility();
            updateResolutionUI();
        }
        
        // Event Listeners
        function setupEventListeners() {
            // File input
            elements.imageInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            elements.dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.dropZone.classList.add('dragover');
            });
            elements.dropZone.addEventListener('dragleave', () => {
                elements.dropZone.classList.remove('dragover');
            });
            elements.dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            // Hue weight controls
            elements.hueWeight.addEventListener('change', triggerConvert);
            elements.hueWeightAmount.addEventListener('input', () => {
                elements.hueWeightValue.textContent = elements.hueWeightAmount.value + '%';
                triggerConvert();
            });
            
            // PCG unlimited toggle
            elements.pcgUnlimited.addEventListener('change', () => {
                updatePcgLimitVisibility();
                triggerConvert();
            });
            
            // Sliders
            elements.pcgLimit.addEventListener('input', () => {
                elements.pcgLimitValue.textContent = elements.pcgLimit.value;
                elements.infoPcgLimit.textContent = elements.pcgLimit.value;
                triggerConvert();
            });
            
            elements.similarity.addEventListener('input', () => {
                elements.similarityValue.textContent = elements.similarity.value;
                triggerConvert();
            });
            
            // Edge protection controls
            elements.edgeProtection.addEventListener('change', triggerConvert);
            elements.edgeProtectionAmount.addEventListener('input', () => {
                elements.edgeProtectionValue.textContent = elements.edgeProtectionAmount.value + '%';
                triggerConvert();
            });
            
            elements.brightness.addEventListener('input', () => {
                elements.brightnessValue.textContent = elements.brightness.value;
                triggerConvert();
            });
            
            elements.contrast.addEventListener('input', () => {
                elements.contrastValue.textContent = elements.contrast.value;
                triggerConvert();
            });
            
            elements.saturation.addEventListener('input', () => {
                elements.saturationValue.textContent = elements.saturation.value;
                triggerConvert();
            });
            
            // Selects
            elements.outputMode.addEventListener('change', () => {
                updateResolutionUI();
                triggerConvert();
            });
            elements.ditherMode.addEventListener('change', triggerConvert);
            
            // Crop position slider
            elements.cropPosition.addEventListener('input', () => {
                elements.cropPositionValue.textContent = elements.cropPosition.value + '%';
                triggerConvert();
            });
            
            // Buttons
            elements.convertBtn.addEventListener('click', () => convert());
            elements.convertBtnTop.addEventListener('click', () => convert());
            elements.saveSettings.addEventListener('click', saveSettings);
            elements.resetSettings.addEventListener('click', resetSettings);
            elements.progressCancel.addEventListener('click', cancelConversion);
            
            elements.downloadOutput.addEventListener('click', () => downloadCanvas(elements.outputCanvas, 'x1_output.png'));
            elements.copyOutput.addEventListener('click', () => copyCanvasToClipboard(elements.outputCanvas));
            elements.downloadPcg.addEventListener('click', () => downloadCanvas(elements.pcgCanvas, 'x1_pcg.png'));
            elements.copyPcg.addEventListener('click', () => copyCanvasToClipboard(elements.pcgCanvas));
            
            // Zoom controls
            document.querySelectorAll('.zoom-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const zoomValue = btn.dataset.zoom;
                    const zoom = zoomValue === 'fit' ? 'fit' : parseFloat(zoomValue);
                    const target = btn.dataset.target;
                    
                    // Update active state
                    document.querySelectorAll(`.zoom-btn[data-target="${target}"]`).forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    if (target === 'output') {
                        outputZoom = zoom;
                        updateOutputDisplay();
                    } else {
                        pcgZoom = zoom;
                        updatePcgDisplay();
                    }
                });
            });
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }
        
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showToast('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sourceImage = img;
                    elements.inputPreview.innerHTML = '';
                    const previewImg = document.createElement('img');
                    previewImg.src = e.target.result;
                    elements.inputPreview.appendChild(previewImg);
                    
                    showToast('ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚å¤‰æ›ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function triggerConvert() {
            if (!sourceImage || !elements.realtimePreview.checked) return;
            
            clearTimeout(convertTimeout);
            convertTimeout = setTimeout(() => {
                convert();
            }, 300);
        }
        
        function updateAllValues() {
            elements.cropPositionValue.textContent = elements.cropPosition.value + '%';
            elements.hueWeightValue.textContent = elements.hueWeightAmount.value + '%';
            elements.pcgLimitValue.textContent = elements.pcgLimit.value;
            elements.similarityValue.textContent = elements.similarity.value;
            elements.edgeProtectionValue.textContent = elements.edgeProtectionAmount.value + '%';
            elements.brightnessValue.textContent = elements.brightness.value;
            elements.contrastValue.textContent = elements.contrast.value;
            elements.saturationValue.textContent = elements.saturation.value;
            elements.infoPcgLimit.textContent = elements.pcgUnlimited.checked ? 'âˆ' : elements.pcgLimit.value;
        }

        function getVisibleCenterY() {
            try {
                if (window.parent !== window && window.frameElement) {
                    const rect = window.frameElement.getBoundingClientRect();
                    const parentVH = window.parent.innerHeight;
                    const visibleTop = Math.max(0, -rect.top);
                    const visibleBottom = Math.min(rect.height, parentVH - rect.top);
                    return visibleTop + (visibleBottom - visibleTop) / 2;
                }
            } catch (e) {}
            return window.scrollY + window.innerHeight / 2;
        }

        function setParentScroll(lock) {
            try {
                if (window.parent !== window && window.frameElement) {
                    window.parent.document.body.style.overflow = lock ? 'hidden' : '';
                }
            } catch (e) {}
            document.body.style.overflow = lock ? 'hidden' : '';
        }

        function showOverlay() {
            setParentScroll(true);
            const content = elements.processingOverlay.querySelector('.processing-content');
            content.style.top = getVisibleCenterY() + 'px';
            elements.processingOverlay.classList.add('active');
        }

        function hideOverlay() {
            setParentScroll(false);
            elements.processingOverlay.classList.remove('active');
        }
        
        // Progress UI functions
        const PHASES = [
            { id: 'preprocess', name: 'å‰å‡¦ç†', weight: 5 },
            { id: 'colorAdjust', name: 'è‰²èª¿æ•´', weight: 5 },
            { id: 'dither', name: 'ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°', weight: 15 },
            { id: 'extract', name: 'ã‚¿ã‚¤ãƒ«æŠ½å‡º', weight: 10 },
            { id: 'unique', name: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯æ¤œå‡º', weight: 15 },
            { id: 'reduce', name: 'PCGãƒªãƒ‡ãƒ¥ãƒ¼ã‚¹', weight: 40 },
            { id: 'rebuild', name: 'ç”»åƒå†æ§‹ç¯‰', weight: 10 }
        ];
        
        function updateProgress(phaseIndex, phasePercent, detail = '') {
            const phase = PHASES[phaseIndex];
            const totalPhases = PHASES.length;
            
            // Calculate overall progress
            let overallPercent = 0;
            for (let i = 0; i < phaseIndex; i++) {
                overallPercent += PHASES[i].weight;
            }
            overallPercent += (phase.weight * phasePercent / 100);
            
            // Normalize to 100%
            const totalWeight = PHASES.reduce((sum, p) => sum + p.weight, 0);
            overallPercent = Math.round(overallPercent / totalWeight * 100);
            
            elements.progressPhase.textContent = `ãƒ•ã‚§ãƒ¼ã‚º ${phaseIndex + 1}/${totalPhases}: ${phase.name}`;
            elements.progressPercent.textContent = `${overallPercent}%`;
            elements.progressBar.style.width = `${overallPercent}%`;
            elements.progressDetail.textContent = detail;
        }
        
        function resetProgress() {
            elements.progressTitle.textContent = 'ğŸ”„ å¤‰æ›å‡¦ç†ä¸­...';
            elements.progressPhase.textContent = 'ãƒ•ã‚§ãƒ¼ã‚º 1/7: å‰å‡¦ç†';
            elements.progressPercent.textContent = '0%';
            elements.progressBar.style.width = '0%';
            elements.progressDetail.textContent = '';
        }
        
        // Inline Web Worker code
        function createWorkerCode() {
            return `
                // Digital 8 colors palette
                const PALETTE = [
                    { r: 0, g: 0, b: 0 },
                    { r: 0, g: 0, b: 255 },
                    { r: 255, g: 0, b: 0 },
                    { r: 0, g: 255, b: 0 },
                    { r: 255, g: 0, b: 255 },
                    { r: 0, g: 255, b: 255 },
                    { r: 255, g: 255, b: 0 },
                    { r: 255, g: 255, b: 255 }
                ];
                
                const BAYER2 = [[0, 2], [3, 1]];
                const BAYER4 = [
                    [0, 8, 2, 10],
                    [12, 4, 14, 6],
                    [3, 11, 1, 9],
                    [15, 7, 13, 5]
                ];
                
                // RGB to HSL
                function rgbToHsl(r, g, b) {
                    r /= 255; g /= 255; b /= 255;
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;
                    if (max === min) {
                        h = s = 0;
                    } else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                            case g: h = ((b - r) / d + 2) / 6; break;
                            case b: h = ((r - g) / d + 4) / 6; break;
                        }
                    }
                    return { h: h * 360, s: s * 100, l: l * 100 };
                }
                
                function hueDistance(h1, h2) {
                    const diff = Math.abs(h1 - h2);
                    return Math.min(diff, 360 - diff);
                }
                
                function colorDistanceWithHue(c1, c2, hueWeightEnabled, hueWeightAmount) {
                    const rgbDist = Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
                    if (!hueWeightEnabled) return rgbDist;
                    const hsl1 = rgbToHsl(c1.r, c1.g, c1.b);
                    const hsl2 = rgbToHsl(c2.r, c2.g, c2.b);
                    const hueDist = hueDistance(hsl1.h, hsl2.h) / 180;
                    const avgSat = (hsl1.s + hsl2.s) / 2 / 100;
                    const effectiveHueDist = hueDist * avgSat;
                    const weight = hueWeightAmount / 100;
                    const hueContrib = effectiveHueDist * 50000 * weight;
                    return rgbDist * (1 - weight * 0.5) + hueContrib;
                }
                
                function findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount) {
                    let minDist = Infinity;
                    let nearest = PALETTE[0];
                    const srcColor = { r, g, b };
                    for (const color of PALETTE) {
                        const dist = colorDistanceWithHue(srcColor, color, hueWeightEnabled, hueWeightAmount);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = color;
                        }
                    }
                    return nearest;
                }
                
                function calculateTileEdgeStrength(tileData) {
                    let edgeSum = 0;
                    for (let y = 1; y < 7; y++) {
                        for (let x = 1; x < 7; x++) {
                            const getLum = (dx, dy) => {
                                const idx = ((y + dy) * 8 + (x + dx)) * 4;
                                return 0.299 * tileData[idx] + 0.587 * tileData[idx + 1] + 0.114 * tileData[idx + 2];
                            };
                            const gx = getLum(1, -1) + 2 * getLum(1, 0) + getLum(1, 1) - getLum(-1, -1) - 2 * getLum(-1, 0) - getLum(-1, 1);
                            const gy = getLum(-1, 1) + 2 * getLum(0, 1) + getLum(1, 1) - getLum(-1, -1) - 2 * getLum(0, -1) - getLum(1, -1);
                            edgeSum += Math.sqrt(gx * gx + gy * gy);
                        }
                    }
                    return edgeSum / 36;
                }
                
                function applyColorAdjustments(data, width, height, settings) {
                    const brightness = settings.brightness / 100;
                    const contrast = (settings.contrast + 100) / 100;
                    const saturation = (settings.saturation + 100) / 100;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i + 1], b = data[i + 2];
                        r = Math.max(0, Math.min(255, r + brightness * 255));
                        g = Math.max(0, Math.min(255, g + brightness * 255));
                        b = Math.max(0, Math.min(255, b + brightness * 255));
                        r = Math.max(0, Math.min(255, (r - 128) * contrast + 128));
                        g = Math.max(0, Math.min(255, (g - 128) * contrast + 128));
                        b = Math.max(0, Math.min(255, (b - 128) * contrast + 128));
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = Math.max(0, Math.min(255, gray + (r - gray) * saturation));
                        g = Math.max(0, Math.min(255, gray + (g - gray) * saturation));
                        b = Math.max(0, Math.min(255, gray + (b - gray) * saturation));
                        data[i] = r; data[i + 1] = g; data[i + 2] = b;
                    }
                    return data;
                }
                
                function applyDithering(data, width, height, settings, progressCallback) {
                    const mode = settings.ditherMode;
                    const hueWeightEnabled = settings.hueWeight;
                    const hueWeightAmount = settings.hueWeightAmount;
                    
                    if (mode === 'none') {
                        for (let i = 0; i < data.length; i += 4) {
                            const nearest = findNearestColor(data[i], data[i + 1], data[i + 2], hueWeightEnabled, hueWeightAmount);
                            data[i] = nearest.r; data[i + 1] = nearest.g; data[i + 2] = nearest.b;
                        }
                    } else if (mode === 'bayer2' || mode === 'bayer4') {
                        const matrix = mode === 'bayer2' ? BAYER2 : BAYER4;
                        const size = matrix.length;
                        const divisor = size * size;
                        for (let y = 0; y < height; y++) {
                            if (y % 20 === 0) progressCallback(Math.round(y / height * 100));
                            for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const threshold = (matrix[y % size][x % size] / divisor - 0.5) * 128;
                                const nearest = findNearestColor(data[i] + threshold, data[i + 1] + threshold, data[i + 2] + threshold, hueWeightEnabled, hueWeightAmount);
                                data[i] = nearest.r; data[i + 1] = nearest.g; data[i + 2] = nearest.b;
                            }
                        }
                    } else if (mode === 'floyd') {
                        const errors = new Float32Array(width * height * 3);
                        for (let y = 0; y < height; y++) {
                            if (y % 20 === 0) progressCallback(Math.round(y / height * 100));
                            for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const ei = (y * width + x) * 3;
                                const r = data[i] + errors[ei];
                                const g = data[i + 1] + errors[ei + 1];
                                const b = data[i + 2] + errors[ei + 2];
                                const nearest = findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount);
                                data[i] = nearest.r; data[i + 1] = nearest.g; data[i + 2] = nearest.b;
                                const errR = r - nearest.r, errG = g - nearest.g, errB = b - nearest.b;
                                if (x + 1 < width) { errors[ei + 3] += errR * 7/16; errors[ei + 4] += errG * 7/16; errors[ei + 5] += errB * 7/16; }
                                if (y + 1 < height) {
                                    if (x > 0) { const ni = ei + width*3 - 3; errors[ni] += errR * 3/16; errors[ni+1] += errG * 3/16; errors[ni+2] += errB * 3/16; }
                                    const ni = ei + width*3; errors[ni] += errR * 5/16; errors[ni+1] += errG * 5/16; errors[ni+2] += errB * 5/16;
                                    if (x + 1 < width) { const ni2 = ei + width*3 + 3; errors[ni2] += errR/16; errors[ni2+1] += errG/16; errors[ni2+2] += errB/16; }
                                }
                            }
                        }
                    } else if (mode === 'atkinson') {
                        const errors = new Float32Array(width * height * 3);
                        for (let y = 0; y < height; y++) {
                            if (y % 20 === 0) progressCallback(Math.round(y / height * 100));
                            for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const ei = (y * width + x) * 3;
                                const r = data[i] + errors[ei];
                                const g = data[i + 1] + errors[ei + 1];
                                const b = data[i + 2] + errors[ei + 2];
                                const nearest = findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount);
                                data[i] = nearest.r; data[i + 1] = nearest.g; data[i + 2] = nearest.b;
                                const errR = (r - nearest.r) / 8, errG = (g - nearest.g) / 8, errB = (b - nearest.b) / 8;
                                const offsets = [[1,0],[2,0],[-1,1],[0,1],[1,1],[0,2]];
                                for (const [ox, oy] of offsets) {
                                    const nx = x + ox, ny = y + oy;
                                    if (nx >= 0 && nx < width && ny < height) {
                                        const ni = (ny * width + nx) * 3;
                                        errors[ni] += errR; errors[ni+1] += errG; errors[ni+2] += errB;
                                    }
                                }
                            }
                        }
                    }
                    return data;
                }
                
                function extractTile(data, width, height, startX, startY) {
                    const tile = new Uint8ClampedArray(8 * 8 * 4);
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            const srcX = Math.min(startX + x, width - 1);
                            const srcY = Math.min(startY + y, height - 1);
                            const srcI = (srcY * width + srcX) * 4;
                            const dstI = (y * 8 + x) * 4;
                            tile[dstI] = data[srcI]; tile[dstI+1] = data[srcI+1]; tile[dstI+2] = data[srcI+2]; tile[dstI+3] = 255;
                        }
                    }
                    return tile;
                }
                
                function tileDifference(tile1, tile2) {
                    let diff = 0;
                    for (let i = 0; i < tile1.length; i += 4) {
                        diff += Math.abs(tile1[i] - tile2[i]);
                        diff += Math.abs(tile1[i + 1] - tile2[i + 1]);
                        diff += Math.abs(tile1[i + 2] - tile2[i + 2]);
                    }
                    return diff;
                }
                
                function tilesAreSimilar(tile1, tile2, threshold) {
                    return tileDifference(tile1, tile2) <= threshold;
                }
                
                function writeTile(data, width, height, startX, startY, tile) {
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            const dstX = startX + x, dstY = startY + y;
                            if (dstX < width && dstY < height) {
                                const dstI = (dstY * width + dstX) * 4;
                                const srcI = (y * 8 + x) * 4;
                                data[dstI] = tile[srcI]; data[dstI+1] = tile[srcI+1]; data[dstI+2] = tile[srcI+2]; data[dstI+3] = 255;
                            }
                        }
                    }
                }
                
                self.onmessage = function(e) {
                    const { imageData, width, height, settings } = e.data;
                    const data = new Uint8ClampedArray(imageData);
                    
                    // Phase 1: Preprocess (already done on main thread)
                    self.postMessage({ type: 'progress', phase: 0, percent: 100, detail: '' });
                    
                    // Phase 2: Color adjustments
                    self.postMessage({ type: 'progress', phase: 1, percent: 0, detail: 'æ˜åº¦/ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ/å½©åº¦ é©ç”¨ä¸­...' });
                    applyColorAdjustments(data, width, height, settings);
                    self.postMessage({ type: 'progress', phase: 1, percent: 100, detail: '' });
                    
                    // Phase 3: Dithering
                    self.postMessage({ type: 'progress', phase: 2, percent: 0, detail: '8è‰²æ¸›è‰²ä¸­...' });
                    applyDithering(data, width, height, settings, (p) => {
                        self.postMessage({ type: 'progress', phase: 2, percent: p, detail: 'è¡Œ: ' + Math.round(p * height / 100) + '/' + height });
                    });
                    self.postMessage({ type: 'progress', phase: 2, percent: 100, detail: '' });
                    
                    // Phase 4: Tile extraction
                    const tilesX = Math.ceil(width / 8);
                    const tilesY = Math.ceil(height / 8);
                    const totalTiles = tilesX * tilesY;
                    const tiles = [];
                    
                    self.postMessage({ type: 'progress', phase: 3, percent: 0, detail: 'ã‚¿ã‚¤ãƒ«: 0/' + totalTiles });
                    for (let ty = 0; ty < tilesY; ty++) {
                        for (let tx = 0; tx < tilesX; tx++) {
                            const tile = extractTile(data, width, height, tx * 8, ty * 8);
                            const edgeStrength = settings.edgeProtection ? calculateTileEdgeStrength(tile) : 0;
                            tiles.push({ x: tx, y: ty, data: tile, edgeStrength });
                        }
                        if (ty % 5 === 0) {
                            const progress = Math.round((ty + 1) / tilesY * 100);
                            self.postMessage({ type: 'progress', phase: 3, percent: progress, detail: 'ã‚¿ã‚¤ãƒ«: ' + tiles.length + '/' + totalTiles });
                        }
                    }
                    self.postMessage({ type: 'progress', phase: 3, percent: 100, detail: '' });
                    
                    // Phase 5: Find unique tiles
                    self.postMessage({ type: 'progress', phase: 4, percent: 0, detail: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚¿ã‚¤ãƒ«æ¤œå‡ºä¸­...' });
                    const uniqueTiles = [];
                    const tileMapping = new Array(tiles.length);
                    const threshold = settings.similarity * 64;
                    
                    for (let i = 0; i < tiles.length; i++) {
                        let foundMatch = -1;
                        for (let j = 0; j < uniqueTiles.length; j++) {
                            if (tilesAreSimilar(tiles[i].data, uniqueTiles[j].data, threshold)) {
                                foundMatch = j;
                                break;
                            }
                        }
                        if (foundMatch >= 0) {
                            tileMapping[i] = foundMatch;
                        } else {
                            tileMapping[i] = uniqueTiles.length;
                            uniqueTiles.push({ ...tiles[i], originalIndex: i });
                        }
                        if (i % 50 === 0) {
                            const progress = Math.round((i + 1) / tiles.length * 100);
                            self.postMessage({ type: 'progress', phase: 4, percent: progress, detail: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯: ' + uniqueTiles.length + ' å€‹ (æ¤œæŸ»: ' + (i+1) + '/' + tiles.length + ')' });
                        }
                    }
                    self.postMessage({ type: 'progress', phase: 4, percent: 100, detail: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯: ' + uniqueTiles.length + ' å€‹æ¤œå‡º' });
                    
                    // Phase 6: Reduce if needed
                    const initialUnique = uniqueTiles.length;
                    if (!settings.pcgUnlimited && uniqueTiles.length > settings.pcgLimit) {
                        const target = settings.pcgLimit;
                        const toReduce = initialUnique - target;
                        let reduced = 0;
                        const edgeProtectionStrength = settings.edgeProtectionAmount / 100;
                        
                        self.postMessage({ type: 'progress', phase: 5, percent: 0, detail: initialUnique + ' â†’ ' + target + ' å‰Šæ¸›ä¸­... (æ®‹ã‚Š ' + toReduce + ')' });
                        
                        while (uniqueTiles.length > target) {
                            let minScore = Infinity;
                            let mergeA = 0, mergeB = 1;
                            
                            for (let i = 0; i < uniqueTiles.length; i++) {
                                for (let j = i + 1; j < uniqueTiles.length; j++) {
                                    const diff = tileDifference(uniqueTiles[i].data, uniqueTiles[j].data);
                                    let score = diff;
                                    if (settings.edgeProtection) {
                                        const edgePenaltyI = uniqueTiles[i].edgeStrength * edgeProtectionStrength * 10000;
                                        const edgePenaltyJ = uniqueTiles[j].edgeStrength * edgeProtectionStrength * 10000;
                                        score = diff - Math.min(edgePenaltyI, edgePenaltyJ);
                                    }
                                    if (score < minScore) {
                                        minScore = score;
                                        mergeA = i;
                                        mergeB = j;
                                    }
                                }
                            }
                            
                            if (settings.edgeProtection && uniqueTiles[mergeB].edgeStrength > uniqueTiles[mergeA].edgeStrength) {
                                [mergeA, mergeB] = [mergeB, mergeA];
                            }
                            
                            for (let i = 0; i < tileMapping.length; i++) {
                                if (tileMapping[i] === mergeB) tileMapping[i] = mergeA;
                                else if (tileMapping[i] > mergeB) tileMapping[i]--;
                            }
                            uniqueTiles.splice(mergeB, 1);
                            reduced++;
                            
                            if (reduced % 10 === 0 || uniqueTiles.length === target) {
                                const progress = Math.round(reduced / toReduce * 100);
                                const remaining = uniqueTiles.length - target;
                                self.postMessage({ type: 'progress', phase: 5, percent: progress, detail: 'ç¾åœ¨: ' + uniqueTiles.length + ' â†’ ç›®æ¨™: ' + target + ' (æ®‹ã‚Š ' + remaining + ')' });
                            }
                        }
                    } else {
                        self.postMessage({ type: 'progress', phase: 5, percent: 100, detail: settings.pcgUnlimited ? 'ç„¡åˆ¶é™ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒªãƒ‡ãƒ¥ãƒ¼ã‚¹ãªã—ï¼‰' : 'ä¸Šé™å†…ã®ãŸã‚ãƒªãƒ‡ãƒ¥ãƒ¼ã‚¹ä¸è¦' });
                    }
                    
                    // Phase 7: Rebuild image
                    self.postMessage({ type: 'progress', phase: 6, percent: 0, detail: 'ç”»åƒå†æ§‹ç¯‰ä¸­...' });
                    const newData = new Uint8ClampedArray(data.length);
                    for (let i = 0; i < tiles.length; i++) {
                        const tileIndex = tileMapping[i];
                        const tileData = uniqueTiles[tileIndex].data;
                        writeTile(newData, width, height, tiles[i].x * 8, tiles[i].y * 8, tileData);
                        if (i % 100 === 0) {
                            const progress = Math.round((i + 1) / tiles.length * 100);
                            self.postMessage({ type: 'progress', phase: 6, percent: progress, detail: 'ã‚¿ã‚¤ãƒ«é…ç½®: ' + (i+1) + '/' + tiles.length });
                        }
                    }
                    self.postMessage({ type: 'progress', phase: 6, percent: 100, detail: '' });
                    
                    // Send result
                    self.postMessage({
                        type: 'complete',
                        imageData: newData.buffer,
                        tiles: uniqueTiles.map(t => Array.from(t.data)),
                        tileCount: uniqueTiles.length
                    }, [newData.buffer]);
                };
            `;
        }
        
        // Main conversion
        async function convert() {
            if (!sourceImage) {
                showToast('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // Cancel any existing worker
            if (currentWorker) {
                currentWorker.terminate();
                currentWorker = null;
            }
            
            conversionCancelled = false;
            resetProgress();
            showOverlay();
            
            // Use setTimeout to allow UI update
            await new Promise(resolve => setTimeout(resolve, 50));
            
            try {
                const settings = getSettings();
                
                // Calculate output dimensions with crop info
                const dims = calculateDimensions(sourceImage.width, sourceImage.height, settings.outputMode, settings.cropPosition);
                
                // Update crop direction labels
                if (dims.cropDirection === 'horizontal') {
                    elements.cropLabelLeft.textContent = 'å·¦';
                    elements.cropLabelRight.textContent = 'å³';
                } else {
                    elements.cropLabelLeft.textContent = 'ä¸Š';
                    elements.cropLabelRight.textContent = 'ä¸‹';
                }
                
                // Phase 0: Preprocess on main thread
                updateProgress(0, 0, 'ãƒªã‚µã‚¤ã‚ºãƒ»ãƒˆãƒªãƒŸãƒ³ã‚°ä¸­...');
                
                // Create working canvas
                const workCanvas = document.createElement('canvas');
                workCanvas.width = dims.width;
                workCanvas.height = dims.height;
                const workCtx = workCanvas.getContext('2d');
                
                // Draw with center crop
                workCtx.imageSmoothingEnabled = false;
                workCtx.drawImage(
                    sourceImage,
                    dims.cropX, dims.cropY, dims.srcW, dims.srcH,
                    0, 0, dims.width, dims.height
                );
                
                // Get image data
                const imageData = workCtx.getImageData(0, 0, dims.width, dims.height);
                updateProgress(0, 100, '');
                
                // Create inline worker
                const workerBlob = new Blob([createWorkerCode()], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(workerBlob);
                currentWorker = new Worker(workerUrl);
                
                // Handle worker messages
                currentWorker.onmessage = function(e) {
                    if (conversionCancelled) return;
                    
                    if (e.data.type === 'progress') {
                        updateProgress(e.data.phase, e.data.percent, e.data.detail);
                    } else if (e.data.type === 'complete') {
                        // Conversion complete
                        const resultData = new Uint8ClampedArray(e.data.imageData);
                        const resultImageData = new ImageData(resultData, dims.width, dims.height);
                        
                        // Reconstruct tiles from arrays
                        const tiles = e.data.tiles.map(arr => new Uint8ClampedArray(arr));
                        
                        // Update output canvas
                        workCtx.putImageData(resultImageData, 0, 0);
                        elements.outputCanvas.width = dims.width;
                        elements.outputCanvas.height = dims.height;
                        const outputCtx = elements.outputCanvas.getContext('2d');
                        outputCtx.imageSmoothingEnabled = false;
                        outputCtx.drawImage(workCanvas, 0, 0);
                        
                        // Generate PCG definition image
                        generatePcgImage(tiles);
                        
                        // Update info
                        const displayLimit = settings.pcgUnlimited ? 'âˆ' : settings.pcgLimit;
                        updateInfo(dims, { tileCount: e.data.tileCount }, displayLimit, settings.cropPosition);
                        
                        // Update display
                        updateOutputDisplay();
                        updatePcgDisplay();
                        
                        // Cleanup
                        currentWorker.terminate();
                        currentWorker = null;
                        URL.revokeObjectURL(workerUrl);
                        hideOverlay();
                        
                        showToast('å¤‰æ›å®Œäº†ï¼');
                    }
                };
                
                currentWorker.onerror = function(error) {
                    console.error('Worker error:', error);
                    showToast('å¤‰æ›ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                    currentWorker.terminate();
                    currentWorker = null;
                    URL.revokeObjectURL(workerUrl);
                    hideOverlay();
                };
                
                // Send data to worker
                currentWorker.postMessage({
                    imageData: imageData.data.buffer,
                    width: dims.width,
                    height: dims.height,
                    settings: settings
                }, [imageData.data.buffer]);
                
            } catch (error) {
                console.error('Conversion error:', error);
                showToast('å¤‰æ›ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                hideOverlay();
            }
        }
        
        // Cancel conversion
        function cancelConversion() {
            conversionCancelled = true;
            if (currentWorker) {
                currentWorker.terminate();
                currentWorker = null;
            }
            hideOverlay();
            showToast('å¤‰æ›ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
        }
        
        function calculateDimensions(srcWidth, srcHeight, mode, cropPosition = 50) {
            let width, height;
            
            // Resolution definitions
            const resolutions = {
                'x1': { w: 320, h: 200 },
                'x1x2': { w: 640, h: 400 },
                'x1x4': { w: 1280, h: 800 },
                'qvga': { w: 320, h: 240 },
                'vga': { w: 640, h: 480 },
                'svga': { w: 800, h: 600 },
                'xga': { w: 1024, h: 768 },
                'sxga': { w: 1280, h: 1024 },
                'hd': { w: 1280, h: 720 },
                'uxga': { w: 1600, h: 1200 },
                'fhd': { w: 1920, h: 1080 },
                'wuxga': { w: 1920, h: 1200 },
                'qhd': { w: 2560, h: 1440 },
                'qxga': { w: 2048, h: 1536 },
                'uhd': { w: 3840, h: 2160 }
            };
            
            if (resolutions[mode]) {
                width = resolutions[mode].w;
                height = resolutions[mode].h;
            } else if (mode === 'auto' || mode === 'autox2' || mode === 'autox4') {
                // Auto mode with optional multiplier
                const multiplier = mode === 'autox4' ? 4 : (mode === 'autox2' ? 2 : 1);
                const baseSize = 240 * multiplier;
                
                const aspect = srcWidth / srcHeight;
                if (aspect >= 1) {
                    height = baseSize;
                    width = Math.round(height * aspect);
                } else {
                    width = Math.round(baseSize * 4 / 3);  // Base width for portrait
                    height = Math.round(width / aspect);
                }
                // Align to 8 pixels
                width = Math.floor(width / 8) * 8;
                height = Math.floor(height / 8) * 8;
                width = Math.max(8, width);
                height = Math.max(8, height);
            } else {
                // Fallback to X1
                width = 320;
                height = 200;
            }
            
            // Calculate crop from source based on cropPosition (25-75%)
            const outputAspect = width / height;
            const srcAspect = srcWidth / srcHeight;
            
            let srcW, srcH, cropX, cropY;
            const positionRatio = (cropPosition - 25) / 50;
            
            if (srcAspect > outputAspect) {
                srcH = srcHeight;
                srcW = Math.round(srcHeight * outputAspect);
                const maxCropX = srcWidth - srcW;
                cropX = Math.floor(maxCropX * positionRatio);
                cropY = 0;
            } else {
                srcW = srcWidth;
                srcH = Math.round(srcWidth / outputAspect);
                const maxCropY = srcHeight - srcH;
                cropY = Math.floor(maxCropY * positionRatio);
                cropX = 0;
            }
            
            const cropDirection = srcAspect > outputAspect ? 'horizontal' : 'vertical';
            
            return { width, height, cropX, cropY, srcW, srcH, cropDirection };
        }
        
        // Check if resolution is high-res (requires unlimited PCG)
        function isHighResolution(mode) {
            const highResModes = ['svga', 'xga', 'sxga', 'hd', 'uxga', 'fhd', 'wuxga', 'qhd', 'qxga', 'uhd', 'x1x4', 'autox4'];
            // Also check autox2 and x1x2 which exceed 640x480
            const mediumResModes = ['x1x2', 'autox2', 'vga'];
            
            if (highResModes.includes(mode)) return true;
            if (mediumResModes.includes(mode)) return false;  // VGA boundary, not high-res
            
            return false;
        }
        
        // Update UI based on resolution selection
        function updateResolutionUI() {
            const mode = elements.outputMode.value;
            const isHighRes = isHighResolution(mode);
            
            // Show/hide high-res note
            elements.highResNote.style.display = isHighRes ? 'block' : 'none';
            
            // Force unlimited mode for high-res
            if (isHighRes) {
                elements.pcgUnlimited.checked = true;
                elements.pcgUnlimited.disabled = true;
            } else {
                elements.pcgUnlimited.disabled = false;
            }
            
            updatePcgLimitVisibility();
        }
        
        function applyColorAdjustments(imageData, settings) {
            const data = imageData.data;
            const brightness = settings.brightness / 100;
            const contrast = (settings.contrast + 100) / 100;
            const saturation = (settings.saturation + 100) / 100;
            
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];
                
                // Brightness
                r += brightness * 255;
                g += brightness * 255;
                b += brightness * 255;
                
                // Contrast
                r = ((r / 255 - 0.5) * contrast + 0.5) * 255;
                g = ((g / 255 - 0.5) * contrast + 0.5) * 255;
                b = ((b / 255 - 0.5) * contrast + 0.5) * 255;
                
                // Saturation
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                r = gray + saturation * (r - gray);
                g = gray + saturation * (g - gray);
                b = gray + saturation * (b - gray);
                
                // Clamp
                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }
            
            return imageData;
        }
        
        function applyDithering(imageData, mode, hueWeightEnabled = false, hueWeightAmount = 0) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            if (mode === 'none') {
                // Simple nearest color
                for (let i = 0; i < data.length; i += 4) {
                    const nearest = findNearestColor(data[i], data[i + 1], data[i + 2], hueWeightEnabled, hueWeightAmount);
                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            } else if (mode === 'bayer2' || mode === 'bayer4') {
                const matrix = mode === 'bayer2' ? BAYER2 : BAYER4;
                const size = matrix.length;
                const divisor = size * size;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const threshold = (matrix[y % size][x % size] / divisor - 0.5) * 128;
                        
                        const r = data[i] + threshold;
                        const g = data[i + 1] + threshold;
                        const b = data[i + 2] + threshold;
                        
                        const nearest = findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount);
                        data[i] = nearest.r;
                        data[i + 1] = nearest.g;
                        data[i + 2] = nearest.b;
                    }
                }
            } else if (mode === 'floyd') {
                // Floyd-Steinberg
                const errors = new Float32Array(width * height * 3);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const ei = (y * width + x) * 3;
                        
                        const r = data[i] + errors[ei];
                        const g = data[i + 1] + errors[ei + 1];
                        const b = data[i + 2] + errors[ei + 2];
                        
                        const nearest = findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount);
                        data[i] = nearest.r;
                        data[i + 1] = nearest.g;
                        data[i + 2] = nearest.b;
                        
                        const errR = r - nearest.r;
                        const errG = g - nearest.g;
                        const errB = b - nearest.b;
                        
                        // Distribute error
                        if (x + 1 < width) {
                            const ni = ei + 3;
                            errors[ni] += errR * 7 / 16;
                            errors[ni + 1] += errG * 7 / 16;
                            errors[ni + 2] += errB * 7 / 16;
                        }
                        if (y + 1 < height) {
                            if (x > 0) {
                                const ni = ei + width * 3 - 3;
                                errors[ni] += errR * 3 / 16;
                                errors[ni + 1] += errG * 3 / 16;
                                errors[ni + 2] += errB * 3 / 16;
                            }
                            const ni = ei + width * 3;
                            errors[ni] += errR * 5 / 16;
                            errors[ni + 1] += errG * 5 / 16;
                            errors[ni + 2] += errB * 5 / 16;
                            if (x + 1 < width) {
                                const ni2 = ei + width * 3 + 3;
                                errors[ni2] += errR * 1 / 16;
                                errors[ni2 + 1] += errG * 1 / 16;
                                errors[ni2 + 2] += errB * 1 / 16;
                            }
                        }
                    }
                }
            } else if (mode === 'atkinson') {
                // Atkinson dithering
                const errors = new Float32Array(width * height * 3);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const ei = (y * width + x) * 3;
                        
                        const r = data[i] + errors[ei];
                        const g = data[i + 1] + errors[ei + 1];
                        const b = data[i + 2] + errors[ei + 2];
                        
                        const nearest = findNearestColor(r, g, b, hueWeightEnabled, hueWeightAmount);
                        data[i] = nearest.r;
                        data[i + 1] = nearest.g;
                        data[i + 2] = nearest.b;
                        
                        const errR = (r - nearest.r) / 8;
                        const errG = (g - nearest.g) / 8;
                        const errB = (b - nearest.b) / 8;
                        
                        // Atkinson: distribute 6/8 of error
                        const offsets = [
                            [1, 0], [2, 0],
                            [-1, 1], [0, 1], [1, 1],
                            [0, 2]
                        ];
                        
                        for (const [ox, oy] of offsets) {
                            const nx = x + ox;
                            const ny = y + oy;
                            if (nx >= 0 && nx < width && ny < height) {
                                const ni = (ny * width + nx) * 3;
                                errors[ni] += errR;
                                errors[ni + 1] += errG;
                                errors[ni + 2] += errB;
                            }
                        }
                    }
                }
            }
            
            return imageData;
        }
        
        // RGB to HSL conversion
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }
        
        // Circular hue distance (0-180)
        function hueDistance(h1, h2) {
            const diff = Math.abs(h1 - h2);
            return Math.min(diff, 360 - diff);
        }
        
        // Color distance with optional hue weighting
        function colorDistanceWithHue(c1, c2, hueWeightEnabled, hueWeightAmount) {
            const rgbDist = Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
            
            if (!hueWeightEnabled) return rgbDist;
            
            const hsl1 = rgbToHsl(c1.r, c1.g, c1.b);
            const hsl2 = rgbToHsl(c2.r, c2.g, c2.b);
            
            const hueDist = hueDistance(hsl1.h, hsl2.h) / 180;
            const avgSat = (hsl1.s + hsl2.s) / 2 / 100;
            const effectiveHueDist = hueDist * avgSat;
            
            const weight = hueWeightAmount / 100;
            const hueContrib = effectiveHueDist * 50000 * weight;
            
            return rgbDist * (1 - weight * 0.5) + hueContrib;
        }
        
        function findNearestColor(r, g, b, hueWeightEnabled = false, hueWeightAmount = 0) {
            let minDist = Infinity;
            let nearest = PALETTE[0];
            const srcColor = { r, g, b };
            
            for (const color of PALETTE) {
                const dist = colorDistanceWithHue(srcColor, color, hueWeightEnabled, hueWeightAmount);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = color;
                }
            }
            
            return nearest;
        }
        
        // Calculate edge strength for a tile (Sobel-based)
        function calculateTileEdgeStrength(tileData) {
            let edgeSum = 0;
            
            for (let y = 1; y < 7; y++) {
                for (let x = 1; x < 7; x++) {
                    const i = (y * 8 + x) * 4;
                    
                    // Get luminance of surrounding pixels
                    const getLum = (dx, dy) => {
                        const idx = ((y + dy) * 8 + (x + dx)) * 4;
                        return 0.299 * tileData[idx] + 0.587 * tileData[idx + 1] + 0.114 * tileData[idx + 2];
                    };
                    
                    // Sobel operators
                    const gx = getLum(1, -1) + 2 * getLum(1, 0) + getLum(1, 1)
                             - getLum(-1, -1) - 2 * getLum(-1, 0) - getLum(-1, 1);
                    const gy = getLum(-1, 1) + 2 * getLum(0, 1) + getLum(1, 1)
                             - getLum(-1, -1) - 2 * getLum(0, -1) - getLum(1, -1);
                    
                    edgeSum += Math.sqrt(gx * gx + gy * gy);
                }
            }
            
            return edgeSum / (6 * 6);  // Normalize
        }
        
        // Update PCG limit settings visibility
        function updatePcgLimitVisibility() {
            const unlimited = elements.pcgUnlimited.checked;
            elements.pcgLimitSettings.style.opacity = unlimited ? '0.5' : '1';
            elements.pcgLimit.disabled = unlimited;
            elements.similarity.disabled = unlimited;
            elements.edgeProtection.disabled = unlimited;
            elements.edgeProtectionAmount.disabled = unlimited;
        }
        
        function processPcgTiles(imageData, width, height, settings) {
            const data = imageData.data;
            const tilesX = Math.ceil(width / 8);
            const tilesY = Math.ceil(height / 8);
            const tiles = [];
            const tileMap = new Map();
            const tileIndices = [];
            
            // Extract all tiles and calculate edge strength
            for (let ty = 0; ty < tilesY; ty++) {
                for (let tx = 0; tx < tilesX; tx++) {
                    const tile = extractTile(data, width, height, tx * 8, ty * 8);
                    const edgeStrength = settings.edgeProtection ? calculateTileEdgeStrength(tile) : 0;
                    tiles.push({ x: tx, y: ty, data: tile, edgeStrength });
                }
            }
            
            // Find unique tiles with similarity threshold
            const uniqueTiles = [];
            const tileMapping = new Array(tiles.length);
            const threshold = settings.similarity * 64; // Scale threshold
            
            for (let i = 0; i < tiles.length; i++) {
                let foundMatch = -1;
                
                for (let j = 0; j < uniqueTiles.length; j++) {
                    if (tilesAreSimilar(tiles[i].data, uniqueTiles[j].data, threshold)) {
                        foundMatch = j;
                        break;
                    }
                }
                
                if (foundMatch >= 0) {
                    tileMapping[i] = foundMatch;
                } else {
                    tileMapping[i] = uniqueTiles.length;
                    uniqueTiles.push({
                        ...tiles[i],
                        originalIndex: i
                    });
                }
            }
            
            // If unlimited mode, skip reduction
            if (!settings.pcgUnlimited && uniqueTiles.length > settings.pcgLimit) {
                // Calculate protection scores for edge protection
                const edgeProtectionStrength = settings.edgeProtectionAmount / 100;
                
                // If over limit, merge most similar tiles (with edge protection)
                while (uniqueTiles.length > settings.pcgLimit) {
                    let minScore = Infinity;
                    let mergeA = 0, mergeB = 1;
                    
                    // Find two most similar tiles (considering edge protection)
                    for (let i = 0; i < uniqueTiles.length; i++) {
                        for (let j = i + 1; j < uniqueTiles.length; j++) {
                            const diff = tileDifference(uniqueTiles[i].data, uniqueTiles[j].data);
                            
                            // Apply edge protection: increase score for edge tiles
                            let score = diff;
                            if (settings.edgeProtection) {
                                const edgePenaltyI = uniqueTiles[i].edgeStrength * edgeProtectionStrength * 10000;
                                const edgePenaltyJ = uniqueTiles[j].edgeStrength * edgeProtectionStrength * 10000;
                                // Higher edge strength = higher penalty = less likely to merge
                                score = diff - Math.min(edgePenaltyI, edgePenaltyJ);
                            }
                            
                            if (score < minScore) {
                                minScore = score;
                                mergeA = i;
                                mergeB = j;
                            }
                        }
                    }
                    
                    // Merge B into A (keep the one with higher edge strength)
                    if (settings.edgeProtection && 
                        uniqueTiles[mergeB].edgeStrength > uniqueTiles[mergeA].edgeStrength) {
                        // Swap: keep B, remove A
                        [mergeA, mergeB] = [mergeB, mergeA];
                    }
                    
                    for (let i = 0; i < tileMapping.length; i++) {
                        if (tileMapping[i] === mergeB) {
                            tileMapping[i] = mergeA;
                        } else if (tileMapping[i] > mergeB) {
                            tileMapping[i]--;
                        }
                    }
                    
                    uniqueTiles.splice(mergeB, 1);
                }
            }
            
            // Rebuild image with mapped tiles
            const newData = new Uint8ClampedArray(data.length);
            
            for (let i = 0; i < tiles.length; i++) {
                const tileIndex = tileMapping[i];
                const tileData = uniqueTiles[tileIndex].data;
                const tx = tiles[i].x;
                const ty = tiles[i].y;
                
                writeTile(newData, width, height, tx * 8, ty * 8, tileData);
            }
            
            return {
                imageData: new ImageData(newData, width, height),
                tiles: uniqueTiles.map(t => t.data),
                tileCount: uniqueTiles.length
            };
        }
        
        function extractTile(data, width, height, startX, startY) {
            const tile = new Uint8ClampedArray(8 * 8 * 4);
            
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const srcX = Math.min(startX + x, width - 1);
                    const srcY = Math.min(startY + y, height - 1);
                    const srcI = (srcY * width + srcX) * 4;
                    const dstI = (y * 8 + x) * 4;
                    
                    tile[dstI] = data[srcI];
                    tile[dstI + 1] = data[srcI + 1];
                    tile[dstI + 2] = data[srcI + 2];
                    tile[dstI + 3] = 255;
                }
            }
            
            return tile;
        }
        
        function writeTile(data, width, height, startX, startY, tile) {
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const dstX = startX + x;
                    const dstY = startY + y;
                    if (dstX < width && dstY < height) {
                        const dstI = (dstY * width + dstX) * 4;
                        const srcI = (y * 8 + x) * 4;
                        
                        data[dstI] = tile[srcI];
                        data[dstI + 1] = tile[srcI + 1];
                        data[dstI + 2] = tile[srcI + 2];
                        data[dstI + 3] = 255;
                    }
                }
            }
        }
        
        function tilesAreSimilar(tile1, tile2, threshold) {
            return tileDifference(tile1, tile2) <= threshold;
        }
        
        function tileDifference(tile1, tile2) {
            let diff = 0;
            for (let i = 0; i < tile1.length; i += 4) {
                diff += Math.abs(tile1[i] - tile2[i]);
                diff += Math.abs(tile1[i + 1] - tile2[i + 1]);
                diff += Math.abs(tile1[i + 2] - tile2[i + 2]);
            }
            return diff;
        }
        
        function generatePcgImage(tiles) {
            const tileCount = tiles.length;
            if (tileCount === 0) {
                elements.pcgCanvas.width = 8;
                elements.pcgCanvas.height = 8;
                return;
            }

            let tilesPerRow = 16;
            if (tileCount > 256) {
                let currentWidthInTiles = 16;
                while (true) {
                    const requiredHeightInTiles = Math.ceil(tileCount / currentWidthInTiles);
                    if (requiredHeightInTiles > currentWidthInTiles) {
                        currentWidthInTiles += 16;
                    } else {
                        tilesPerRow = currentWidthInTiles;
                        break;
                    }
                }
            }

            const rows = Math.ceil(tileCount / tilesPerRow);
            const cols = tilesPerRow;
            
            elements.pcgCanvas.width = cols * 8;
            elements.pcgCanvas.height = rows * 8;
            
            const ctx = elements.pcgCanvas.getContext('2d');
            ctx.clearRect(0, 0, elements.pcgCanvas.width, elements.pcgCanvas.height); 
            const imageData = ctx.createImageData(cols * 8, rows * 8);
            
            for (let i = 0; i < tileCount; i++) {
                const col = i % tilesPerRow;
                const row = Math.floor(i / tilesPerRow);
                writeTile(imageData.data, cols * 8, rows * 8, col * 8, row * 8, tiles[i]);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function calculateFitZoom(canvasWidth, canvasHeight, containerWidth, containerHeight) {
            if (canvasWidth === 0 || canvasHeight === 0) return 1;
            const scaleX = containerWidth / canvasWidth;
            const scaleY = containerHeight / canvasHeight;
            return Math.min(scaleX, scaleY, 1);  // Don't enlarge beyond 1x
        }
        
        function updateOutputDisplay() {
            const canvas = elements.outputCanvas;
            const wrapper = elements.outputWrapper;
            
            if (outputZoom === 'fit') {
                // FIT mode: calculate zoom to fit in container
                const containerWidth = wrapper.clientWidth - 20;  // padding
                const containerHeight = Math.min(wrapper.clientHeight || 400, 600);
                const fitZoom = calculateFitZoom(canvas.width, canvas.height, containerWidth, containerHeight);
                canvas.style.width = Math.floor(canvas.width * fitZoom) + 'px';
                canvas.style.height = Math.floor(canvas.height * fitZoom) + 'px';
            } else {
                canvas.style.width = Math.floor(canvas.width * outputZoom) + 'px';
                canvas.style.height = Math.floor(canvas.height * outputZoom) + 'px';
            }
        }
        
        function updatePcgDisplay() {
            const canvas = elements.pcgCanvas;
            const wrapper = elements.pcgWrapper;
            
            if (pcgZoom === 'fit') {
                // FIT mode
                const containerWidth = wrapper.clientWidth - 20;
                const containerHeight = Math.min(wrapper.clientHeight || 400, 600);
                const fitZoom = calculateFitZoom(canvas.width, canvas.height, containerWidth, containerHeight);
                canvas.style.width = Math.floor(canvas.width * fitZoom) + 'px';
                canvas.style.height = Math.floor(canvas.height * fitZoom) + 'px';
            } else {
                canvas.style.width = Math.floor(canvas.width * pcgZoom) + 'px';
                canvas.style.height = Math.floor(canvas.height * pcgZoom) + 'px';
            }
        }
        
        function updateInfo(dims, pcgResult, limit, cropPosition) {
            elements.infoResolution.textContent = `${dims.width} Ã— ${dims.height}`;
            elements.infoTiles.textContent = `${Math.ceil(dims.width / 8)} Ã— ${Math.ceil(dims.height / 8)}`;
            elements.infoPcgUsed.textContent = pcgResult.tileCount;
            
            // Show crop info
            if (dims.cropX > 0 || dims.cropY > 0) {
                const direction = dims.cropDirection === 'horizontal' ? 'å·¦å³' : 'ä¸Šä¸‹';
                elements.infoCrop.textContent = `${direction} ${cropPosition}%`;
            } else {
                elements.infoCrop.textContent = 'ãªã—';
            }
            elements.infoAlign.textContent = (dims.width % 8 === 0 && dims.height % 8 === 0) ? 'âœ“ OK' : 'âœ—';
            
            const percentage = Math.round((pcgResult.tileCount / limit) * 100);
            elements.pcgPercentage.textContent = `${percentage}%`;
            elements.pcgBarFill.style.width = `${Math.min(100, percentage)}%`;
            
            // Color coding
            elements.pcgBarFill.classList.remove('warning', 'danger');
            if (percentage >= 100) {
                elements.pcgBarFill.classList.add('danger');
            } else if (percentage >= 80) {
                elements.pcgBarFill.classList.add('warning');
            }
        }
        
        function getSettings() {
            return {
                outputMode: elements.outputMode.value,
                cropPosition: parseInt(elements.cropPosition.value),
                ditherMode: elements.ditherMode.value,
                hueWeight: elements.hueWeight.checked,
                hueWeightAmount: parseInt(elements.hueWeightAmount.value),
                pcgUnlimited: elements.pcgUnlimited.checked,
                pcgLimit: parseInt(elements.pcgLimit.value),
                similarity: parseInt(elements.similarity.value),
                edgeProtection: elements.edgeProtection.checked,
                edgeProtectionAmount: parseInt(elements.edgeProtectionAmount.value),
                brightness: parseInt(elements.brightness.value),
                contrast: parseInt(elements.contrast.value),
                saturation: parseInt(elements.saturation.value),
                realtimePreview: elements.realtimePreview.checked
            };
        }
        
        function saveSettings() {
            const settings = getSettings();
            document.cookie = `x1pcg_settings=${JSON.stringify(settings)}; max-age=31536000; path=/`;
            showToast('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        function loadSettings() {
            const match = document.cookie.match(/x1pcg_settings=([^;]+)/);
            if (match) {
                try {
                    const settings = JSON.parse(match[1]);
                    applySettings(settings);
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }
        
        function applySettings(settings) {
            elements.outputMode.value = settings.outputMode || defaultSettings.outputMode;
            elements.cropPosition.value = settings.cropPosition || defaultSettings.cropPosition;
            elements.ditherMode.value = settings.ditherMode || defaultSettings.ditherMode;
            elements.hueWeight.checked = settings.hueWeight !== undefined ? settings.hueWeight : defaultSettings.hueWeight;
            elements.hueWeightAmount.value = settings.hueWeightAmount || defaultSettings.hueWeightAmount;
            elements.pcgUnlimited.checked = settings.pcgUnlimited !== undefined ? settings.pcgUnlimited : defaultSettings.pcgUnlimited;
            elements.pcgLimit.value = settings.pcgLimit || defaultSettings.pcgLimit;
            elements.similarity.value = settings.similarity || defaultSettings.similarity;
            elements.edgeProtection.checked = settings.edgeProtection !== undefined ? settings.edgeProtection : defaultSettings.edgeProtection;
            elements.edgeProtectionAmount.value = settings.edgeProtectionAmount || defaultSettings.edgeProtectionAmount;
            elements.brightness.value = settings.brightness || defaultSettings.brightness;
            elements.contrast.value = settings.contrast || defaultSettings.contrast;
            elements.saturation.value = settings.saturation || defaultSettings.saturation;
            elements.realtimePreview.checked = settings.realtimePreview !== undefined ? settings.realtimePreview : defaultSettings.realtimePreview;
            updateAllValues();
            updatePcgLimitVisibility();
        }
        
        function resetSettings() {
            applySettings(defaultSettings);
            showToast('è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
            if (sourceImage) {
                convert();
            }
        }
        
        function downloadCanvas(canvas, filename) {
            const dataUrl = canvas.toDataURL('image/png');
            
            // iOS Safariå¯¾å¿œ: aã‚¿ã‚°ã®downloadå±æ€§ãŒåŠ¹ã‹ãªã„å ´åˆãŒã‚ã‚‹
            // æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ã„ã¦é•·æŠ¼ã—ä¿å­˜ã‚’æ¡ˆå†…
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            if (isIOS) {
                // iOSã®å ´åˆ: æ–°ã—ã„ã‚¿ãƒ–ã§ç”»åƒã‚’é–‹ã
                const newTab = window.open();
                if (newTab) {
                    newTab.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta name="viewport" content="width=device-width, initial-scale=1">
                            <title>${filename}</title>
                            <style>
                                body { 
                                    margin: 0; 
                                    padding: 20px; 
                                    background: #1a1a2e; 
                                    color: #eee;
                                    font-family: -apple-system, sans-serif;
                                    text-align: center;
                                }
                                img { 
                                    image-rendering: pixelated; 
                                    border: 2px solid #333;
                                    max-width: 100%;
                                    margin-top: 10px;
                                }
                                p { margin: 15px 0; font-size: 16px; }
                                .hint { 
                                    background: #e94560; 
                                    padding: 15px; 
                                    border-radius: 8px;
                                    margin: 10px;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="hint">ğŸ“± ç”»åƒã‚’é•·æŠ¼ã— â†’ã€Œå†™çœŸã«è¿½åŠ ã€ã§ä¿å­˜</div>
                            <img src="${dataUrl}" />
                        </body>
                        </html>
                    `);
                    newTab.document.close();
                    showToast('æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ãã¾ã—ãŸ');
                } else {
                    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯æ™‚ã¯data URLã‚’ç›´æ¥é–‹ã
                    window.location.href = dataUrl;
                }
            } else {
                // PC/Androidã®å ´åˆ: é€šå¸¸ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const link = document.createElement('a');
                link.download = filename;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
            }
        }
        
        async function copyCanvasToClipboard(canvas) {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            // iOSã®å ´åˆã¯ç›´æ¥ç”»åƒè¡¨ç¤ºã¸
            if (isIOS) {
                openImageInNewTab(canvas, 'ç”»åƒã‚’é•·æŠ¼ã—ã§ã‚³ãƒ”ãƒ¼ã¾ãŸã¯ä¿å­˜');
                return;
            }
            
            // ã¾ãšClipboard APIã‚’è©¦ã™
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                showToast('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                return;
            } catch (e) {
                console.log('Clipboard API not available, using fallback');
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ–°ã—ã„ã‚¿ãƒ–ã§ç”»åƒã‚’é–‹ã
            openImageInNewTab(canvas, 'ç”»åƒã‚’å³ã‚¯ãƒªãƒƒã‚¯ â†’ã€Œç”»åƒã‚’ã‚³ãƒ”ãƒ¼ã€');
        }
        
        function openImageInNewTab(canvas, message) {
            try {
                const dataUrl = canvas.toDataURL('image/png');
                const newTab = window.open();
                if (newTab) {
                    newTab.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta name="viewport" content="width=device-width, initial-scale=1">
                            <title>ç”»åƒ</title>
                            <style>
                                body { 
                                    margin: 0; 
                                    padding: 20px; 
                                    background: #1a1a2e; 
                                    color: #eee;
                                    font-family: -apple-system, sans-serif;
                                    text-align: center;
                                }
                                img { 
                                    image-rendering: pixelated; 
                                    border: 2px solid #333;
                                    max-width: 100%;
                                    margin-top: 10px;
                                }
                                .hint { 
                                    background: #e94560; 
                                    padding: 15px; 
                                    border-radius: 8px;
                                    margin: 10px;
                                    font-size: 16px;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="hint">ğŸ“‹ ${message}</div>
                            <img src="${dataUrl}" />
                        </body>
                        </html>
                    `);
                    newTab.document.close();
                    showToast('æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ãã¾ã—ãŸ');
                } else {
                    showToast('ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
                }
            } catch (e) {
                console.error('Failed to open image:', e);
                showToast('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }
        
        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => {
                elements.toast.classList.remove('show');
            }, 2000);
        }
        
        // Initialize on load
        init();
        
        // Handle window resize for FIT mode
        window.addEventListener('resize', () => {
            if (outputZoom === 'fit') updateOutputDisplay();
            if (pcgZoom === 'fit') updatePcgDisplay();
        });

        // Notify parent frame of content height for auto-sizing iframe
        (function() {
            if (window.parent === window) return;
            let lastHeight = 0;
            function notifyHeight() {
                const height = document.documentElement.scrollHeight;
                if (height !== lastHeight) {
                    lastHeight = height;
                    window.parent.postMessage({ type: 'x1pcg-resize', height: height }, '*');
                }
            }
            const ro = new ResizeObserver(notifyHeight);
            ro.observe(document.body);
            notifyHeight();
        })();
    </script>
</body>
</html>
